const TelegramBot = require("node-telegram-bot-api");
const axios = require("axios");
const schedule = require("node-schedule"); // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º node-schedule
const mongoose = require("mongoose");

// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ MongoDB
mongoose
  .connect(
    "mongodb+srv://Roman:Hozo323@cluster0.fuq2s.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0",
    {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    }
  )
  .then(() => console.log("Connected to MongoDB Atlas"))
  .catch((err) => console.log("Error connecting to MongoDB:", err));

// –°—Ö–µ–º–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
const userSchema = new mongoose.Schema({
  userId: { type: Number, required: true, unique: true },
  chatId: { type: Number, required: true },
  firstName: { type: String, required: true },
  lastName: { type: String },
  dateFirstLogin: { type: String },
  language: { type: String, default: "ru" },
  trackedPairs: [
    {
      pair: { type: String, required: true },
      abbreviation: { type: String, required: true },
      isTracked: { type: Boolean, default: false },
      price: { type: Number, default: null },
    },
  ],
});

const User = mongoose.model("User", userSchema);

const token = "7470408844:AAEDBELxri3Bq8AF-AHTRmVzqzMVFNrtnow";
const bot = new TelegramBot(token, { polling: true });

let defaultPairs = [
  { id: 1, pair: "bitcoin", abbreviation: "BTC", isTracked: false, price: null },
  { id: 2, pair: "ethereum", abbreviation: "ETH", isTracked: false, price: null },
  { id: 3, pair: "litecoin", abbreviation: "LTC", isTracked: false, price: null },
  { id: 4, pair: "ripple", abbreviation: "XRP", isTracked: false, price: null },
  { id: 5, pair: "cardano", abbreviation: "ADA", isTracked: false, price: null },
  { id: 6, pair: "eos", abbreviation: "EOS", isTracked: false, price: null },
  { id: 7, pair: "cosmos", abbreviation: "ATOM", isTracked: false, price: null },
  { id: 8, pair: "bitcoin-cash", abbreviation: "BCH", isTracked: false, price: null },
  { id: 9, pair: "dogecoin", abbreviation: "DOGE", isTracked: false, price: null },
  { id: 10, pair: "polkadot", abbreviation: "DOT", isTracked: false, price: null },
  { id: 11, pair: "ethereum-classic", abbreviation: "ETC", isTracked: false, price: null },
  { id: 12, pair: "gas", abbreviation: "GAS", isTracked: false, price: null },
  { id: 13, pair: "stellar", abbreviation: "XLM", isTracked: false, price: null },
  { id: 14, pair: "0x", abbreviation: "ZRX", isTracked: false, price: null },
];


bot.setMyCommands([
  { command: '/pairs', description: '–í—ã–±–æ—Ä –ø–∞—Ä' }
  
]);
// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
// async function addOrUpdateUser(
//   userId,
//   chatId,
//   firstName,
//   lastName,
//   dateFirstLogin,
//   language,
//   trackedPairs
// ) {
//   try {
//     let user = await User.findOne({ userId });

//     if (user) {
//       // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω, –æ–±–Ω–æ–≤–ª—è–µ–º –µ–≥–æ –¥–∞–Ω–Ω—ã–µ
//       user.chatId = chatId;
//       user.trackedPairs = trackedPairs;
//     } else {
//       // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ
//       user = new User({
//         userId,
//         chatId,
//         firstName,
//         lastName,
//         dateFirstLogin,
//         language,
//         trackedPairs,
//       });
//       await user.save();
//     }

//     console.log(`User ${userId} saved or updated successfully.`);
//   } catch (error) {
//     console.error("Error saving/updating user:", error);
//   }
// }




// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –∏—Ö –¥–∞–Ω–Ω—ã—Ö
async function getAllUsers() {
  try {
    const users = await User.find();
    return users;
  } catch (error) {
    console.error("Error fetching users:", error);
    return [];
  }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö —Ü–µ–Ω
async function getPrices(trackingPairs, userId) {
  try {
    const response = await axios.get(
      "https://api.coingecko.com/api/v3/simple/price",
      {
        params: {
          ids: trackingPairs.map((pair) => pair.pair).join(","),
          vs_currencies: "usd",
        },
      }
    );

    let pricesChanged = false;

    trackingPairs.forEach((pair) => {
      const newPrice = response.data[pair.pair]
        ? response.data[pair.pair].usd
        : null;
      if (pair.price !== newPrice) {
        pair.price = newPrice;
        pricesChanged = true;
      }
    });

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Ü–µ–Ω—ã –≤ –±–∞–∑–µ
    if (pricesChanged) {
      const user = await User.findOne({ userId });
      if (user) {
        user.trackedPairs = trackingPairs;
        await user.save();
      }
    }

    return pricesChanged;
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ü–µ–Ω:", error);
    return false;
  }
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫ —Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º–∏ —Ü–µ–Ω–∞–º–∏
function generateButtons(trackingPairs) {
  return trackingPairs.map((pair) => {
    const symbol = pair.isTracked ? "‚úÖ" : "";
    const price = pair.price ? `$ ${pair.price.toFixed(2)}` : "–ó–∞–≥—Ä—É–∑–∫–∞...";
    return [
      {
        text: `${symbol} ${pair.abbreviation} - ${price}`,
        callback_data: pair.pair,
      },
    ];
  });
}

const getUsefulData = async () => {
  const now = new Date();
  // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É –¥–ª—è —Ä—É—Å—Å–∫–æ–π –ª–æ–∫–∞–ª–∏
  const formattedDate = now.toLocaleString("ru-RU", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
  });
  return formattedDate;
};

// –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ —Ü–µ–Ω—ã –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
bot.onText(/\/start/, async (msg) => {
  const formattedDate = await getUsefulData();
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const firstName = msg.from.first_name;
  const lastName = msg.from.last_name || "";
  const language = msg.from.language_code || "ru";
  const dateFirstLogin = formattedDate;

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –±–∞–∑–µ
  let user = await User.findOne({ userId });

  if (!user) {
    // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ—Ç, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ —Å –º–∞—Å—Å–∏–≤–æ–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã—Ö –ø–∞—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    user = new User({
      userId,
      chatId,
      firstName,
      lastName,
      dateFirstLogin,
      language,
      trackedPairs: defaultPairs, // –ú–∞—Å—Å–∏–≤ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã—Ö –ø–∞—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    });
    await user.save();
    console.log(`User ${userId} created with default tracking pairs.`);
  } else {
    // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω, –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º –µ–≥–æ chatId (–µ—Å–ª–∏ —ç—Ç–æ –Ω—É–∂–Ω–æ)
    console.log(`User ${userId} found and updated.`);
  }

  // –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∞—Å—Å–∏–≤ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã—Ö –ø–∞—Ä –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
  const trackedPairs = user.trackedPairs;

  // –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
  const fName = msg.chat.first_name || "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å";
  const lName = msg.chat.last_name || "";
  bot.sendMessage(chatId, "–ü—Ä–∏–≤–µ—Ç, " + fName + " " + (lName ? lName : ""));

  // –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ —Ü–µ–Ω—ã –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã—Ö –ø–∞—Ä
  await getPrices(trackedPairs);

  const options = {
    reply_markup: {
      inline_keyboard: [
        [{ text: "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä—ã", callback_data: "select_pair" }],
      ],
    },
  };

  bot.sendMessage(
    chatId,
    "–ü—Ä–∏–≤–µ—Ç! –ù–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –≤—ã–±–æ—Ä–∞ –ø–∞—Ä:",
    options
  ); 

});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä—ã"
bot.on("callback_query", async (query) => {
  const { data, message, from } = query;
  const userId = from.id;

  // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ
  const user = await User.findOne({ userId });

  if (!user) {
    bot.answerCallbackQuery(query.id, { text: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω!" });
    return;
  }

  const trackedPairs = user.trackedPairs;

  if (data === "select_pair") {
    // –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—ã –∏ —Ç–æ–ª—å–∫–æ –ø–æ—Ç–æ–º –æ–±–Ω–æ–≤–ª—è–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    const pricesUpdated = await getPrices(trackedPairs, userId);

    if (pricesUpdated) {
      const options = {
        reply_markup: {
          inline_keyboard: generateButtons(trackedPairs),
        },
      };

      bot.editMessageText("–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä—É –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è:", {
        chat_id: message.chat.id,
        message_id: message.message_id,
        reply_markup: options.reply_markup,
      });

      
    } else {
      bot.answerCallbackQuery(query.id, { text: "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Ü–µ–Ω—ã!" });
    }
  } else {
    // –õ–æ–≥–∏–∫–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
    const pairIndex = trackedPairs.findIndex((pair) => pair.pair === data);
    if (pairIndex !== -1) {
      trackedPairs[pairIndex].isTracked = !trackedPairs[pairIndex].isTracked;

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –±–∞–∑–µ
      user.trackedPairs = trackedPairs;
      await user.save();

      const updatedKeyboard = generateButtons(trackedPairs);

      await bot.editMessageReplyMarkup(
        { inline_keyboard: updatedKeyboard },
        { chat_id: message.chat.id, message_id: message.message_id }
      );
    }
  }

  bot.answerCallbackQuery(query.id); // –£–±–∏—Ä–∞–µ–º "—á–∞—Å–∏–∫–∏" –Ω–∞ –∫–Ω–æ–ø–∫–µ
});

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π —Ü–µ–Ω
async function checkPriceChanges() {
  console.log("–ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω...");

  try {
    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ –±–∞–∑—ã
    const users = await getAllUsers();

    if (users.length === 0) {
      console.log("–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.");
      return;
    }

    // –°–æ–±–∏—Ä–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ø–∞—Ä—ã –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤
    const pairsToTrack = [
      ...new Set(
        users.flatMap((user) =>
          user.trackedPairs
            .filter((pair) => pair.isTracked)
            .map((pair) => pair.pair)
        )
      ),
    ];

    if (pairsToTrack.length === 0) {
      console.log("–ù–µ—Ç –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã—Ö –ø–∞—Ä.");
      return;
    }

    // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ —Ü–µ–Ω—ã
    const response = await axios.get(
      "https://api.coingecko.com/api/v3/simple/price",
      {
        params: {
          ids: pairsToTrack.join(","),
          vs_currencies: "usd",
        },
      }
    );

    const currentPrices = response.data;
    console.log(currentPrices);

    // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    const updatedUsers = [];

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –¥–ª—è –∫–∞–∂–¥–æ–π –ø–∞—Ä—ã –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    for (const user of users) {
      let updated = false; // –§–ª–∞–≥ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π

      for (const pair of user.trackedPairs.filter((p) => p.isTracked)) {
        const currentPrice = currentPrices[pair.pair]?.usd;

        if (currentPrice) {
          const priceChange =
            Math.round(((currentPrice - pair.price) / pair.price) * 100 * 100) /
            100;

          // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Ä–æ–≥ –≤ 0.5%
          if (Math.abs(priceChange) >= 0.1) {
            // const formattedPair = pair.pair.charAt(0).toUpperCase() + pair.pair.slice(1);
            const formattedAbbreviation = pair.abbreviation.toUpperCase();
            console.log(
              `‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${user.firstName}: —Ü–µ–Ω–∞ –ø–∞—Ä—ã ${formattedAbbreviation} –∏–∑–º–µ–Ω–∏–ª–∞—Å—å –Ω–∞ ${priceChange}%`
            );

            // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            bot.sendMessage(
              user.chatId,
              `üîî –¶–µ–Ω–∞ –ø–∞—Ä—ã ${formattedAbbreviation}/USD –∏–∑–º–µ–Ω–∏–ª–∞—Å—å –±–æ–ª–µ–µ —á–µ–º –Ω–∞ ${priceChange}%!\n–°—Ç–∞—Ä–∞—è —Ü–µ–Ω–∞: ${pair.price}\n–ù–æ–≤–∞—è —Ü–µ–Ω–∞: ${currentPrice}`
            );

            pair.price = currentPrice; // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–µ–Ω—É –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
            updated = true; // –û—Ç–º–µ—á–∞–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±—ã–ª –æ–±–Ω–æ–≤–ª–µ–Ω
          }
        }
      }

      // –ï—Å–ª–∏ –±—ã–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è, –¥–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —Å–ø–∏—Å–æ–∫ –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö
      if (updated) {
        updatedUsers.push(user);
      }
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ –±–∞–∑–µ
    await Promise.all(
      updatedUsers.map((user) =>
        User.updateOne(
          { userId: user.userId },
          { trackedPairs: user.trackedPairs }
        )
      )
    );
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π —Ü–µ–Ω:", error.message);
  }
};

// –í—ã–±–æ—Ä –ø–∞—Ä, —á—Ç–æ –±—ã –≤–µ—Ä–Ω—É—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –Ω–∏–∑ –¥–∏–∞–ª–æ–≥–∞
bot.onText(/\/pairs/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
  const user = await User.findOne({ userId });

  if (!user) {
    bot.sendMessage(chatId, "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.");
    return;
  }

  const trackedPairs = user.trackedPairs;

  // –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ —Ü–µ–Ω—ã
  const pricesUpdated = await getPrices(trackedPairs, userId);

  if (pricesUpdated) {
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–∞—Ä
    const options = {
      reply_markup: {
        inline_keyboard: generateButtons(trackedPairs),
      },
    };

    bot.sendMessage(chatId, "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä—É –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è:", options);
  } else {
    bot.sendMessage(chatId, "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Ü–µ–Ω—ã.");
  }
});



// –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞—á—É —Ä–∞–∑ –≤ 20 —Å–µ–∫—É–Ω–¥
schedule.scheduleJob("*/20 * * * * *", checkPriceChanges);

